---
path: "/chapters/eth1/evm"
title: "The Ethereum Virtual Machine"
status: "1"
---

Bad draft for EVM section

So at this point we've already discussed how state is represented in Ethereum and what transactions look like. You should know that there are two types of accounts, user accounts and contract accounts. Now we will discuss the state transition function in Ethereum, which is essentially how Ethereum takes in a transaction and actually uses that information to change the world state we described earlier. 

The heart of the Eth1 state transition function is something called the Ethereum Virtual Machine. We need to first understand what a virtual machine is before we continue. Essentially, "real" computers consist of some processing chip and memory, these two work together to do computer tasks. The processing chip receives information in the form of instructions, which then either performs mathematical operations on the inputs or can read and write from memory. This very basic primitive allows the computer to do essentially anything we want.

Ethereum was designed to vastly expand the types of applications someone could build on a blockchain. In order to achieve this, it introduces a "virtual" machine, essentially a computer inside a computer. It's not a specific physical computer, it's basically just a program itself that has an internal representation of memory and can process operations. Since this does a majority of the heavy lifting, let's look at how the Ethereum Virtual Machine works under the hood. 

The EVM has two areas of memory that it works with. The first of these is the world state. This is exactly the world state we described previously, basically when we run the EVM we load the world state into the EVM so that the world state can be accessed by programs inside of it. This is what allows a contract to retrieve data from other contracts or interact with other contracts. Contracts can access the world state of their own contract ("storage") or can make contract calls to other contracts.

The second area of memory is the working memory or simply "program memory." This is called volatile memory because it only exists for the duration of a program execution, it's not saved to the world state but only used to help the EVM figure out how to run a specific program. The machine state consists of four primary sub-elements. 

The first element of the machine state is the "stack." This essentially holds the variables that the EVM is working with at any given time. Variables and values can be pushed or popped from the stack. For instance, if the EVM wants to add two numbers together, it will put the numbers onto the stack and then pop the two and add the results together, then push the result back onto the stack. The EVM is therefore a "stack-based" virtual machine, as opposed to the more common "register-based" virtual machines.

Other than the stack, the EVM machine state also has "memory" which is a small memory space where values go while they're being manipulated. This is where stuff would go when an addition is being made, the values would be popped from the stack and put into the short-term memory until they're rewritten back to the stack. Essentially this is a helper space necessary during computation.

diagram

Finally, the EVM also has a program counter and a gas available counter. The program counter basically tells the EVM where it is during the execution of a given program. It points to the specific instruction that the EVM is currently supposed to operate, where the total instructions in a program are listed out as a big list. The EVM has jump operations that allow the program counter to be manipulated in order to create loops in execution. The gas available counter is essentially just that, a record of how much gas is still available for execution of the current program. This counter is decremented every time an instruction is carried out, based on the exact gas cost of the instruction.

diagram

These are the primary elements of the EVM that make it work. From here, we can actually use the EVM to execute programs that change the state. So let's examine how a program might do this. We are going to start with an extremely simple contract that demonstrates how a basic transaction would be executed in the EVM.

Programs in the EVM take the form of low-level bytecode that makes to instructions. A full list of instructions is available on this page. Here, we're going to be using a high-level programming langauge called Solidity so that this is actually readible. We will then convert this into EVM assembly, so that we can see how things would work. Here, our simple contract just stores a "value" that can be incremented through a function called "increment." The function takes an amount, and the value will be increased by the given amount.

```solidity
contract SimpleContract {
	uint256 value;

	function increment(uint256 amount) public {
		value += amount;
	}
}
```

Very simple indeed. Now this contract corresponds to the following assembly code. We've highlighted the different "areas" of the contract.

```
.code
  PUSH 80			contract SimpleContract {\n   ...
  PUSH 40			contract SimpleContract {\n   ...
  MSTORE 			contract SimpleContract {\n   ...
  CALLVALUE 			contract SimpleContract {\n   ...
  DUP1 			olidity ^
  ISZERO 			a 
  PUSH [tag] 1			a 
  JUMPI 			a 
  PUSH 0			a
  DUP1 			n
  REVERT 			.0;\n\ncontrac
tag 1			a 
  JUMPDEST 			a 
  POP 			contract SimpleContract {\n   ...
  PUSH #[$] 0000000000000000000000000000000000000000000000000000000000000000			contract SimpleContract {\n   ...
  DUP1 			contract SimpleContract {\n   ...
  PUSH [$] 0000000000000000000000000000000000000000000000000000000000000000			contract SimpleContract {\n   ...
  PUSH 0			contract SimpleContract {\n   ...
  CODECOPY 			contract SimpleContract {\n   ...
  PUSH 0			contract SimpleContract {\n   ...
  RETURN 			contract SimpleContract {\n   ...
.data
  0:
    .code
      PUSH 80			contract SimpleContract {\n   ...
      PUSH 40			contract SimpleContract {\n   ...
      MSTORE 			contract SimpleContract {\n   ...
      CALLVALUE 			contract SimpleContract {\n   ...
      DUP1 			olidity ^
      ISZERO 			a 
      PUSH [tag] 1			a 
      JUMPI 			a 
      PUSH 0			a
      DUP1 			n
      REVERT 			.0;\n\ncontrac
    tag 1			a 
      JUMPDEST 			a 
      POP 			contract SimpleContract {\n   ...
      PUSH 4			contract SimpleContract {\n   ...
      CALLDATASIZE 			contract SimpleContract {\n   ...
      LT 			contract SimpleContract {\n   ...
      PUSH [tag] 2			contract SimpleContract {\n   ...
      JUMPI 			contract SimpleContract {\n   ...
      PUSH 0			contract SimpleContract {\n   ...
      CALLDATALOAD 			contract SimpleContract {\n   ...
      PUSH E0			contract SimpleContract {\n   ...
      SHR 			contract SimpleContract {\n   ...
      DUP1 			contract SimpleContract {\n   ...
      PUSH 7CF5DAB0			contract SimpleContract {\n   ...
      EQ 			contract SimpleContract {\n   ...
      PUSH [tag] 3			contract SimpleContract {\n   ...
      JUMPI 			contract SimpleContract {\n   ...
    tag 2			contract SimpleContract {\n   ...
      JUMPDEST 			contract SimpleContract {\n   ...
      PUSH 0			contract SimpleContract {\n   ...
      DUP1 			contract SimpleContract {\n   ...
      REVERT 			contract SimpleContract {\n   ...
    tag 3			function increment(uint256 amo...
      JUMPDEST 			function increment(uint256 amo...
      PUSH [tag] 4			function increment(uint256 amo...
      PUSH 4			function increment(uint256 amo...
      DUP1 			function increment(uint256 amo...
      CALLDATASIZE 			function increment(uint256 amo...
      SUB 			function increment(uint256 amo...
      PUSH 20			ty
      DUP2 			oli
      LT 			a solidity 
      ISZERO 			ag
      PUSH [tag] 5			ag
      JUMPI 			ag
      PUSH 0			r
      DUP1 			o
      REVERT 			6.0;\n\ncontra
    tag 5			ag
      JUMPDEST 			ag
      DUP2 			function increment(uint256 amo...
      ADD 			function increment(uint256 amo...
      SWAP1 			function increment(uint256 amo...
      DUP1 			function increment(uint256 amo...
      DUP1 			function increment(uint256 amo...
      CALLDATALOAD 			function increment(uint256 amo...
      SWAP1 			function increment(uint256 amo...
      PUSH 20			function increment(uint256 amo...
      ADD 			function increment(uint256 amo...
      SWAP1 			function increment(uint256 amo...
      SWAP3 			function increment(uint256 amo...
      SWAP2 			function increment(uint256 amo...
      SWAP1 			function increment(uint256 amo...
      POP 			function increment(uint256 amo...
      POP 			function increment(uint256 amo...
      POP 			function increment(uint256 amo...
      PUSH [tag] 6			function increment(uint256 amo...
      JUMP [in]			function increment(uint256 amo...
    tag 4			function increment(uint256 amo...
      JUMPDEST 			function increment(uint256 amo...
      STOP 			function increment(uint256 amo...
    tag 6			function increment(uint256 amo...
      JUMPDEST 			function increment(uint256 amo...
      DUP1 			amount
      PUSH 0			value
      DUP1 			value
      DUP3 			value += amount
      DUP3 			value += amount
      SLOAD 			value += amount
      ADD 			value += amount
      SWAP3 			value += amount
      POP 			value += amount
      POP 			value += amount
      DUP2 			value += amount
      SWAP1 			value += amount
      SSTORE 			value += amount
      POP 			value += amount
      POP 			function increment(uint256 amo...
      JUMP [out]			function increment(uint256 amo...
    .data
```

For now, we're going to avoid the initialization area and just focus on the part that corresponds to our "increment" function. A transaction that calls this function from a user account would look like this:

todo: transaction

We have the sender address, the recipient address (address of our contract), a signature, and we also have the ID of the function being called, plus the amount by which we want to increment the value our input, plus gas information. So that's everything that goes inside the transaciton itself. Now let's see what nodes would do when executing this transaction.

We said the EVM forms the majority of the STf, but there is a little that's outside the EVM itself. Mainly this is the "intrinstic validity checks" that's used to check that the transaction is executible in the first place. These checks look like:

todo: intrinsic validity check code

We're basically just checking that the transaction is correctly signed, well formed, we check the nonce. We also check that the account has enough balance for the fee and reduce their balance by this fee, and then we incrememnt the nonce of the account, and finally we check that the account has enough to cover the base gas cost of every transaciton plust the fee per byte. Once we do all of this, we execute the EVM.

When we run the EVM, the first thing we do is load the world state. We start by pulling the contract code that corresponds to the given contract we care about, specifically the one at the given address. So the EVM would access the world state to pull this code. The EVM now has an idea of what this contract looks like, you can essentially think that the EVM has generated an "object" for the contract. This process looks as follows:

todo: diagram

Once the EVM has this contract and the associated storage, it looks at the transaction itself to see what method is being called. It pulls the method ID and any input data (calldata) from the transaction. Now it begins to execute the method, here specifically the increment method. The EVM starts execution along the method and puts the calldata on the stack.

todo: diagram

Next, the method instructions say to perform an operation called an SLOAD in order to take the current value and put it in a variable, that variable is also stored on the stack.

Then it tells the EVM to add the variable and the input together, which means the EVM pops from the stack the two top values, adds them together, and stores the result.

Finally, the method tells the EVM to STORE the value back to the world state. This completes the method, it's quite simple. Since there's no return value, the method just returns 1 to show that everything went fine. The EVM then hands control back to the state transition function.

The thing that's worth understanding with the EVM is that the EVM is actually aware of the way in which state is represented in Ethereum. It's aware of the idea of a contract, an account, etc. It handles low-level stuff like memory and computation, but it also handles stuff like pulling from the world state. This ties the EVM into the state model of Ethereum. Although this really isn't a big deal in Ethereum, it's something that we change in Eth2, where we try to make Eth2 more general purpose. We'll get to that later.

Other weird things is that the EVM uses 256 bit words, instead of the standard 64 bit words. This isn't totally unusual, there are some machines that use 256 bit words. Some of the main reasons is so that certain typical values (addresses, signatures, etc) fit into a single word. 