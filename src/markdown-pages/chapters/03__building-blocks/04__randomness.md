---
path: "/chapters/building-blocks/randomness"
title: "Randomness"
---


## Understanding Randomness
Ok so basically randomness is important for many different reasons. One of the most important reasons is calling back to the thing we talked about earlier where the Proof of Stake system needs to select block proposers. There are many ways to do this, like the round-robin thing we talked about, but one of the better ways to do this is via randomness. Although round-robin is fair, it is very predictable. This is bad, for example, because it means we know far in advance who has the right to produce a block at a given time. This means we have a lot of time to DOS this producer (cause them to lose out on rewards and also mess with the network) or try to collude with them to do some bad behavior. If we aren't able to predict very far in advance, then we have less time to execute a DOS attack or collude.

However, randomness is an interesting concept in itself and there are many different ideas about it. If I ask you to pick a random number from 1-10, you're more likely to pick 7 than any other number. This obviously isn't a good "source" for randomness. There are other "sources" of randomness we can use, but there's a challenge about getting them into the blockchain. Basically, we need the blockchain itself to create the randomness. This is a really hard problem! If the randomness isn't good, then for example the producers won't be fairly picked meaning soem will get more rewards than they deserve or it will be easy to figure out in advance who will be a producer. that's bad for sure.

So we also use randomness in other places in Eth2. One thing we'll dicsuss later is the idea of "Committees" of validators who are chosen to vote (make attestations on) beacon chain blocks and also vote on shard blocks (more later). Before we talk about thsi in detail, it's important to note that a lot of Ethereum's security is based on good randomness and, if its good, then we have certain guarantees about the likelihood that a committee voting on a shard block will be all malicious. It's very unlikely in this case. However, if the randomness can be biased then it's much mroe likely for this to be the case and we have the potentail problem where invalid shard blocks could be created. there are solutions for this sort of issue (fraud proofs), but they require a rollback of the blockchain which is realy annoying.

One more place where randomness is useful is for applicaitons. Lots of different applications could have a use for randomness. Weve seen this ehavily with things like lotteries or thigns on-chain that want to give money by chance. Gambling basically. You can think of many different applicaitons that could want to use randomness. We want to make sure these applications have a good source of randomness to use.

As a result, it's important that we explain how Eth2 actually achieves this randomness becuase it's something you will have to participate in as a validator. So let's get into it.

## RANDAO
The tool that Eth2 uses to generate random numbers is called RANDAO. RANDAO is actually very simple, so let's go over the basics quickly. So let's say that we just wanted one person to generate a random number for us. Obviously that person could just cheat and pick a "random" number that benefits them in some way. Let's say it wins them the lottery in one of these on-chain games. Obviously not good enough. So we can try something else. Let's instead have a bunch of people generate random numbers and then we combine these numbers together! This is the core of RANDAO. The first idea is that we have everyone generate a random length-n bit string and we XOR the bits of everyone's random number together whch gives us a final number that no one could really predict. 

Here's an example of this:

But well here's an issue. If someone can see everyone elses number in advance, then they can just pick their own number to manipulate the result to their own benefit! Let's say everyone did their values but C picks last. They see that they can just pick XXXXX to get a favorable random number. Ths takes some grinding, but it allows them to really manipulate as much as they want.

Ok obviously this is a start bu no bueno. So now what we do is we add a mechanism so taht you dn't get to see veryones number at first. This is called a commit/reveal scheme and the idea is simple. Basiclaly, first everyone "commits" to their random number. They take the hash of their number and publish it. Once evertyone has published their hash, people start revealing one by one. Now is where it gets interesting. The attacker can basically wait until everyone else has published and they just choose whether to reveal or not. They can't change their number since they already committed to it (revealing a different number gives a different hash), but they do have the option to refuse to reveal. This means they sort of get one more "roll of the dice" and 2^n bits of bias where N is the number of nodes controlled by the attacker in the order of revealing end. So generalyl this is much better then just basic RANDAO, but it's not perfect.

But it is good enough for most purposes and we have some proofs about how much any individual attacker can actually influene the chain here.

## VDFs
We know that RANDAO isn't perfect, but we want to see if it's possible to improve upon it. Some interesting new developments in Cryptography have come where we have the idea of VDFS or verifiable delay functions. The idea behind VDFs is that you are doing a mathematical computation that you must do in serial and cannot parallelize, but that spits out a proof that you did the computation that can be verified in a short period of time. This is sort of coming out of the idea of time-lcok crypto, except that you now have an efficient proof. 

So why do we care? well, they giev us a cool thing if we combine it with RANDAO. The idea is that instead of just waiting for the reveals Or not, we wait for the last reveal and then we use the last value as an input to a VDF. This VDF takes a long time to finish, but then spits out the actaul random number that we will use. The point here is that let's say the attacker has the last validator and can choose whether to reveal or not. However, in order to see how the reveal or not will actually influence the random number, the attacker would have to compute the VDF. This takes longer than 1 slot time, so the attacker doesn't gain any advantage by not revealing. Cool!

One issue with VDFs is basically the advantage proportion. Similar to PoW difficulty, VDFs can be tuned to take a ceratin amount of time to compute the result. This takes much less resouces than PoW of course, but the attacker could get an advantage back if they figure out how to significantly decrease the tme to compute ther esult compared to everyone else. As a result, there's a lot of work going on about getting this advantage down to a minimum, and producing a low-cost ASIC that people could buy (just one per validator!) that would ensure the VDF advantage is minimized. 