---
path: "/chapters/building-blocks/casper-ffg"
title: "Casper FFG"
---


## Background
When we're dealing with financial transactions, we often want to ensure that the transaction has some sense of "finality." If a transaction could be reverted at any time, then most of our economic system wouldn't be functional. For example, imagine that you're going into a small boutique and want to buy some clothes. If there's a significant possibility that your transaction is somehow reversed or is like it never happened, why would the store owner want to sell you anything? Although we do have some forms of this in our lives, mainly in the form of credit card chargebacks, these events are usually reserved for cases of fraud and your credit card company will look into the situation case-by-case. 

Blockchains also need this sort of finality, just like any other transactional system. In traditional Proof of Work blockchains, we get what's called "probabalistic finality." What this basically means is that when there's work done on a block to extend that block, the more work that's done on the block, the less likely that a different competing chain will appear that others will want to build upon. This is, of course, assuming that we follow the rule that if you're honest then you will follow the chain with the most work behind it. The reason why this is probabilistic is because there is always a chance that somehow someone could build a much longer chain by getting really lucky with their hashes. This is actually discussed in the original Bitcoin paper, where it shows how the probability drops off heavily with each additional block on the chain.

In a Proof of Stake system, we want to ensure that we also get some sort of finality. However, it's not expensive to create blocks. In fact, it is very cheap because validators only need to sign a message, which is computationally minimal. However, this opens up a big attack where a validator would just sign off on every different fork because it's worth it for them to do so! This is called the nothing-at-stake problem and means that the blockchain protocol would effectively be incentivized to just sign off on every fork, there really wouldn't be any consensus on a single chain, let alone a finalized chain. So this is where Ethereum introduces Casper FFG. Casper FFG is a mechanism that allows validators to "finalize" blocks created by a block proposal mechanism. We will talk about the specifics of the block proposal mechanism later, but here we first look at the finalization mechanism. Really what finalization means in this context is that validators are agreeing that they won't sign off on forks of ancestors to a finalized block, or they'll be slashed heavily. It gives us certain guarantees about the cost to revert a given previous block.

## Blocks and Slots
Any user in a Proof of Work blockchain has the "right" to publish a new block as long as that block has some specified hash. Generally speaking, this lottery system acts as a proxy for the amount of economic value that the user has invested in the system. Proof of Stake systems similarly attempt to evenly assign the block production rights to users by the amount of economic value invested in the system. However, this now takes the form of the amount of value staked by a known list of validators. There are many potential ways to achieve this. We could, for example, do a simple round-robin system in which validators are allowed to produce X blocks in a row out of N, where X is the amount of stake that validator has and N is the total amount of stake. We could also do a "random" system in which the blockchain attempts to randomly select proposers.

Basically what's necessary to note int he context of proof of stake is that, no matter the system, we need to know for any block who gets the right to produce that block. For example, we could say that user X gets to produce block number 10. We can quickly see a potential issue here. In a Proof of Work system, it's effectively a race to see who gets to produce the block. However, in a Proof of Stake system, we assign this in advance and therefore we know who will produce that block. As a result, it's possible that for some reason the block does not get produced by the assigned validator at some time. If we don't address this issue, then the whole blockchain will stall because the validator didn't produce their block. We have several ways to address this issue. Generally speaking, however, we need to assign some sort of timeout that says that if the validator doesn't produce their block within a given amount of time, we go to the next validator. This naturally leads us to the construction of "slots," periods of time in which a validator is assigned to produce a block and may or may not do so.

Slots are really specific to Proof of Stake blockchains. Proof of Work blockchains typically assign a "height" to every block, where a block's height is equal to its position in the chain. For example, the tenth block following the genesis block will be assigned a height of 10. Generally speaking, the `nth` block following the genesis block has a height of `n`. Proof of Stake blockchains also have block heights, though.

So whereas a Proof of Work blockchain might look something like this:

![Proof of Work block heights](./images/pow-height.png)

Our Proof of Stake chain looks like this:

![Proof of Stake block heights](./images/pos-height.png)

In the above image, we've skipped slots 1 and 3, which means that we didn't see any blocks produced during these slots. The height of the last block in this chain is 2 instead of 4.

## Epochs
Epochs are the important part in FFG. Epochs are chunks of time, specified in PoS as chunks of slots. For example, we can set an epoch to be 64 slots. Epochs are important because they're basically larger time scales on which finality happens. Finality is a generally expensive thing to do, and we want to give the network enough time to see everthing and really come to consensus on what's goign to be considered final and what won't be considered final. If we don't give enough time, then it's possible for someone to violate the rules only because they haven't seen all the messages yet. If we give too much time, then we're stuck waiting forever for finality. But we still want the network to progress in the meanwhile, so the idea is that we have a certain level of security on a shorter time period and a larger level security on a larger time period.

Checkpoints happen on epochs, specifically on what are called epoch boundary blocks. Epoch boundary blocks are key blocks within an epoch. They're effectively the blocks within an epoch that are operated on in other parts of FFG. Epoch boundary blocks aren't necessarily the first block in an epoch. THey're either the block created int he first slot of an epoch OR the last known block carried over to the current epoch, itnerestingly enough. For example, see the following illustration.

## Checkpoints
Checkpoints are the poitns at which the network considers a block and all of its ancestors to be finalized. Checkppoints happen at ebbs. Checkpoints happen during special conditions called justifications are linked. The idea of justifications is that there's a concept of a source and a target. A source is a previously justified block. A target is the next block to be justified. Justifications are official once there are sufficient votes for a justification, in ETh2 case its 2/3 of the validator set. For example, see the following diagram.

Justifications aren't actually checkpoints though. We need a little more ,because there's some extra stuff about the temporaility of a checkpoint. The idea is that checkpoitns should be points taht are *really sure* that there's validity of a network. So what we say is we define a rule about when a justification means a checkpoint. What we want to achieve here is that there needs to be certain justifications within a small period of time that make a checkpoint valid. This satisfies the temporality of the system.

So as a result, we want to define a rule. Originally, we said that justifications became checkpoitns when two EBBs in a row were justified. However, this rule is a little harsh when there is some network delay. Basically it's possible that maybe someone hasn't seen that a block is justified yet, and therefore creates justifications where the soruce is n-1 instead of n for n+1. However then maybe we see that N is actually justified later on during n+2, but we don't know if N+1 is justified yet, so we want to use soruce of n. So then we have this situation where theres justifications for n-1, n+1, and n, n+2. However, obviously this is sort of a situation in which n+1 can be checkpointed because your'e allowed to have missing pieces in the justification link as long as all of the missing pieces are themsevles justified. This is a general rule, but in Eth we only look at the k+2 case because of some stuff we use later on for security.

## Slashing
Slashing is the important thing that provides security for the casper FFg system. Basically we want to punish people who try to evade the casper FFg tools. These conditions are as follows. One slashing condition is that we don't want people to try to finalize two different blocks at the same target height. So we say taht someone gets slashed if they ever publish two justifications where the target height is the same, but the actual target block is different. We also have a second rule called no spanning where you're mot allowed to jump over one of your finalization votes. Where a finalization vote is a vote of one edge ???

## Slashing Conditions
